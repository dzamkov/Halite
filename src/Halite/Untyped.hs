{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE FlexibleContexts #-}
module Halite.Untyped where

import Void
import GHC.Generics
import Control.Applicative
import Control.Monad (ap)

-- | A term in untyped lambda calculus with variables of type @a@.
data Term a
    = Var a
    | App (Term a) (Term a)
    | Lam (Term (Maybe a))
    deriving (Eq, Ord, Show)

instance Functor Term where
    fmap f (Var x) = Var (f x)
    fmap f (App x y) = App (fmap f x) (fmap f y)
    fmap f (Lam inner) = Lam (fmap (fmap f) inner)
instance Applicative Term where
    pure = Var
    (<*>) = ap
instance Monad Term where
    return = Var
    (>>=) (Var x) f = f x
    (>>=) (App x y) f = App (x >>= f) (y >>= f)
    (>>=) (Lam inner) f = Lam (inner >>= maybe (Var Nothing) (fmap Just . f))

-- | Constructs a lambda abstraction over a term.
lam :: (Eq a) => a -> Term a -> Term a
lam var = Lam . fmap (\x -> if x == var then Nothing else Just x)

-- | Converts a term with no free variables into a concrete term.
con :: Term a -> Term Void
con = fmap undefined

-- | Given an infinite list of arguments /a/ and a lambda term /x/, this will
-- try to reduce the term /x a1 a2 a3 .../ into a term /y b1 b2 b3 .../ where
-- /y/ is a variable. This may not terminate for some inputs.
reduce :: [Term a] -> Term a -> (a, [Term a])
reduce args (Var x) = (x, args)
reduce args (App x y) = reduce (y : args) x
reduce (arg : args) (Lam inner) = reduce args (inner >>= maybe arg Var)
reduce [] _ = error "Argument list must be infinite"

-- | Values of type @a@ can be encoded in untyped lambda calculus in a way
-- that is consistent with Church encodings.
class Church a where

    -- | Encodes a value as an untyped lambda term.
    encode :: a -> Term Void
    default encode :: (Generic a, GChurch (Rep a)) => a -> Term Void
    encode = gencode . from

    -- | Decodes a value from an untyped lambda term. This may not succeed
    -- for all terms, but is guranteed to succeed for all terms generated by
    -- an 'encode' for the same type.
    decode :: Term Void -> a

-- | A term which, when evaluated, indicates a 'Church' decoding is malformed.
badTerm :: Term a
badTerm = error "Bad term"

instance Church Bool where
    encode True = con $ lam True $ lam False $ Var True
    encode False = con $ lam True $ lam False $ Var False
    decode = fst . reduce args . fmap undefined where
        args = Var True : Var False : repeat badTerm

-- | Generic version of 'Church'.
class GChurch f where

    -- | Generic version of 'encode'.
    gencode :: f a -> Term Void

    -- | Generic version of 'decode'.
    gdecode :: Term Void -> f a
